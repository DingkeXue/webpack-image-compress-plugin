const Https=require("https"),Url=require("url"),Chalk=require("chalk"),Ora=require("ora"),{DefaultHeader}=require("../utils/header"),{IMG_TEST}=require("../utils/regexp"),{ByteSize}=require("trample/node"),{RawSource}=require("webpack-sources"),pluginName="WebpackImageCompressPlugin";module.exports=class{constructor(e){this._options=Object.assign({log:!0,compress:!0,concurrency:20,minSize:10240,maxSize:-1},e)}apply(e){e.hooks&&this._options.compress?!e.webpack&&void 0!==e.resolvers?e.hooks.emit.tapPromise(pluginName,e=>Promise.resolve(this.handleImgAssets(e))):e.hooks.compilation.tap(pluginName,e=>{e.hooks.processAssets.tapPromise(pluginName,()=>Promise.resolve(this.handleImgAssets(e)))}):e.plugin&&this._options.compress?e.plugin("emit",async(e,s)=>{await this.handleImgAssets(e),s()}):console.log(`The webpack version number supported by ${pluginName} is 3-5！, install: https://webpack.js.org/`)}async handleImgAssets(e){const s=e.assets;let t=Object.keys(e.assets).filter(e=>IMG_TEST.test(e));if(!t.length)return Promise.resolve();t=this.filterImages(t,s);e=t.map(e=>this.compressImg(s,e));const r=Ora("Compressing Image......").start();await this.promiseLimit(e,this._options.concurrency).then(e=>{r.stop(),this._options.log&&e&&e.forEach(e=>console.log(e))})}filterImages(e,s){return e.filter(e=>{e=s[e].source().length;return 0<this._options.maxSize&&0<this._options.minSize?e<=Number(this._options.maxSize)&&e>=Number(this._options.minSize):this._options.minSize?e>=Number(this._options.minSize):!(0<this._options.maxSize)||e<=Number(this._options.maxSize)})}promiseLimit(t,r=20){let o=0;const i=[],n=[],a=function(){if(o===t.length)return Promise.resolve();const e=t[o++];i.push(e);const s=e.then(()=>n.splice(n.indexOf(s),1));return n.push(s),n.length>=r?Promise.race(n).then(()=>a(),e=>Promise.reject(e)):Promise.resolve().then(()=>a())};return a().then(()=>Promise.all(i))}async compressImg(e,s){try{var t=e[s].source(),r=await this.uploadImg(t),o=await this.downloadImg(r.output.url);e[s]=new RawSource(Buffer.alloc(o.length,o,"binary"));var i=Chalk.red(ByteSize(r.input.size)),n=Chalk.green(ByteSize(r.output.size));const a=`Compressed ${[Chalk.yellowBright(s)]} completed! Old Size: ${i}, New Size: ${n}`;return new Promise((e,s)=>e(a))}catch(e){const l=`Compressed [${Chalk.yellowBright(s)}] failed! ${Chalk.red(e)}`;return new Promise((e,s)=>e(l))}}uploadImg(r){const o=DefaultHeader();return new Promise((s,t)=>{const e=Https.request(o,e=>e.on("data",e=>{e=JSON.parse(e.toString());e.error?t(e.message):s(e)}));e.write(r,"binary"),e.on("error",e=>t(e)),e.end()})}downloadImg(e){const r=new Url.URL(e);return new Promise((t,s)=>{const e=Https.request(r,e=>{let s="";e.setEncoding("binary"),e.on("data",e=>s+=e),e.on("end",()=>t(s))});e.on("error",e=>s(e)),e.end()})}};